import re
import numpy as np
from astropy.io import fits
from astropy.io.fits.fitsrec import FITS_rec


def read_header_file(file_path: str, as_dict=False) -> dict | fits.Header:
    """.head or .header file"""
    if as_dict:
        return header_to_dict(file_path)

    else:
        return fits.Header.fromtextfile(file_path)


def header_to_dict(file_path) -> dict:
    """
    Parse a FITS header text file and convert it into a dictionary.

    This function reads a text file containing a FITS (Flexible Image Transport System)
    header generated by the `imhead` command, extracts key-value pairs from each line,
    and stores them in a dictionary.

    The function handles the following cases:
    - String values enclosed in single quotes are stripped of quotes and whitespace.
    - Numerical values are converted to integers or floats when possible.
    - Boolean values (`T` and `F` in FITS format) are converted to Python `True` and `False`.
    - Comments after the `/` character are ignored.

    Args:
        file_path (str): Path to the text file containing the FITS header.

    Returns:
        dict: A dictionary containing the parsed header, where keys are the FITS
        header keywords and values are the corresponding parsed values.

    Example:
        Given a FITS header file with the following lines:
            SIMPLE  = T / file does conform to FITS standard
            BITPIX  = 8 / number of bits per data pixel
            NAXIS   = 0 / number of data axes
            EXTEND  = T / FITS dataset may contain extensions

        The function will return:
        {
            "SIMPLE": True,
            "BITPIX": 8,
            "NAXIS": 0,
            "EXTEND": True
        }
    """
    # Regular expression to match FITS header format
    fits_pattern = re.compile(r"(\S+)\s*=\s*(.+?)(?:\s*/\s*(.*))?$")

    fits_dict = {}
    # Read the FITS header from the text file
    with open(file_path, "r", encoding="utf-8") as file:
        for line in file:
            match = fits_pattern.match(line)
            if match:
                key, value, comment = match.groups()
                value = value.strip()

                # Handle string values enclosed in single quotes
                if value.startswith("'") and value.endswith("'"):
                    value = value.strip("'").strip()

                # Convert numerical values
                else:
                    try:
                        if "." in value:
                            value = float(value)  # Convert to float if it contains a decimal
                        else:
                            value = int(value)  # Convert to integer otherwise
                    except ValueError:
                        pass  # Leave as string if conversion fails

                # Convert boolean values (T/F in FITS format)
                if value == "T":
                    value = True
                elif value == "F":
                    value = False

                fits_dict[key] = value

    return fits_dict


# blindly appending ver.
def update_padded_header(target_fits, header_new: dict | fits.Header, append=True):
    """
    Update a FITS file's header with header_new (scamp or photometry output).
    header_new can be either astropy.io.fits.Header or dict.

    CAVEAT: This overwrites COMMENTs adjacent to the padding

    Args:
        target_fits (str): Path to the target FITS file to be updated
        header_new (dict or Header): Header object with info to be added

    Note:
        - Modifies the target FITS file in-place
        - Preserves existing non-COMMENT header entries
        - Appends or replaces header cards from the input header
    """

    def _update_header(header: fits.Header, header_new):
        cards = header.cards
        # format new header for iteration
        if isinstance(header_new, fits.Header):
            cardpack = header_new.cards
        elif isinstance(header_new, dict):  # (key, value) or (key, (value, comment))
            cardpack = [
                (key, *value) if isinstance(value, tuple) else (key, value) for key, value in header_new.items()
            ]
        else:
            raise ValueError("Unsupported Header format for updating padded Header")

        # i is the last non-comment idx
        for i in range(len(cards) - 1, -1, -1):
            if cards[i][0] != "COMMENT":
                break
        i += 1

        # Expects (key, value, comment)
        for j, card in enumerate(cardpack):
            if i + j <= len(cards) - 1:
                del header[i + j]
                header.insert(i + j, card)
            else:
                header.append(card, end=True)

    with fits.open(target_fits, mode="update") as hdul:
        header = hdul[0].header
        _update_header(header, header_new)


# def update_padded_header(target_fits, header_new):
#     """
#     Update a FITS file's header with header_new (scamp or photometry output).
#     header_new can be either astropy.io.fits.Header or dict.

#     This version will override any existing key/value pairs in-place,
#     and append truly new cards just before the trailing COMMENTs.

#     Args:
#         target_fits (str): Path to the target FITS file to be updated
#         header_new (dict or Header): Header object or mapping with info to be added

#     Note:
#         - Modifies the target FITS file in-place
#         - Preserves existing non-COMMENT header entries (except overridden ones)
#         - Appends only those cards whose keys did not exist before
#     """
#     with fits.open(target_fits, mode="update") as hdul:
#         header: fits.Header = hdul[0].header

#         # Find the index of the last non-COMMENT card
#         last_non_comment = None
#         for idx, card in enumerate(header.cards):
#             if card.keyword != "COMMENT":
#                 last_non_comment = idx

#         insert_pos = (last_non_comment + 1) if last_non_comment is not None else len(header.cards)

#         # Normalize header_new into a list of (key, value, comment) tuples
#         if isinstance(header_new, fits.Header):
#             new_cards = [(c.keyword, c.value, c.comment) for c in header_new.cards]
#         elif isinstance(header_new, dict):
#             new_cards = []
#             for key, val in header_new.items():
#                 if isinstance(val, tuple):
#                     new_cards.append((key, val[0], val[1]))
#                 else:
#                     new_cards.append((key, val, None))
#         else:
#             raise ValueError("Unsupported Header format for updating padded Header")

#         # Apply each new card: override if exists, otherwise append in padding
#         for key, value, comment in new_cards:
#             if key in header:  # override existing
#                 # header.set handles both update and insertion
#                 header.set(key, value, comment or header.comments.get(key))
#             else:
#                 # insert before COMMENTS
#                 header.insert(insert_pos, (key, value, comment), after=False)
#                 insert_pos += 1  # shift insertion point forward


def add_padding(header: fits.Header, n: int, copy_header=False) -> fits.Header:
    """
    Add empty COMMENT entries to a FITS header to ensure specific block sizes.

    This function helps manage FITS header sizes by adding padding comments.
    Useful for maintaining specific header block structures required by
    astronomical data processing tools.

    Args:
        header (fits.Header): Input FITS header
        n (int): Target number of 2880-byte blocks
        copy_header (bool, optional): If True, operates on a copy of the header.
            Defaults to False. Note: Using True is slower.

    Returns:
        fits.Header: Header with added padding comments

    Note:
        - Each COMMENT is 80 bytes long
        - The total header size must be a multiple of 2880 bytes
    """
    if copy_header:
        import copy

        header = copy.deepcopy(header)

    info_size = len(header.cards) * 80

    target_size = (n - 1) * 2880  # fits header size is a multiple of 2880 bytes
    padding_needed = target_size - info_size
    num_comments = padding_needed // 80  # (each COMMENT is 80 bytes)

    # CAVEAT: END also uses one line.
    # for _ in range(num_comments - 1):  # <<< full n-1 2880-byte blocks
    for _ in range(num_comments):  # <<< marginal n blocks
        header.add_comment(" ")

    return header


def remove_padding(header):
    """
    Remove COMMENT padding from a FITS header.

    Strips all trailing COMMENT entries, returning a header with only
    significant entries.

    Args:
        header (fits.Header): Input FITS header with potential padding

    Returns:
        fits.Header: Header with padding comments removed

    Note:
        This method is primarily useful for header inspection and may not
        be directly applicable for header updates.
    """
    # Extract all header cards
    cards = list(header.cards)

    # Find the last non-COMMENT entry
    for i in range(len(cards) - 1, -1, -1):
        if cards[i][0] != "COMMENT":  # i is the last non-comment idx
            break

    return header[: i + 1]


def reset_header(target_image: str, override_header: str | dict | fits.Header = None):
    """
    Reset the header of a FITS file to a supplied header.

    Args:
        target_image (str): Path to the target FITS file to be updated
        override_header (str | dict | fits.Header, optional): Header to be used.
            Defaults to None, which means the header file with the same name as the target image,
            but with a .header extension, will be used.
    """
    structural = ["SIMPLE", "BITPIX", "NAXIS", "NAXIS1", "NAXIS2"]

    if override_header is None:
        override_header = target_image.replace(".fits", ".header")
    if isinstance(override_header, str):
        override_header = read_header_file(override_header)
    elif isinstance(override_header, dict):
        override_header = fits.Header(override_header)

    with fits.open(target_image, mode="update") as hdul:
        header = hdul[0].header
        if len(override_header) >= len(header):
            n_tail = len(override_header) - len(header)
            n_body = len(header)
            more_to_write = True
        else:
            n_tail = len(header) - len(override_header)
            n_body = len(override_header.cards)
            more_to_write = False

        # swap keys for the length of the shorter header
        for i in range(n_body):
            original_card = header.cards[i]
            if original_card.keyword in structural:
                continue
            card = override_header.cards[i]
            # print(f"swapping {original_card.keyword} at {i} with {card}")
            del header[i]
            header.insert(i, card)

        # if there's more to write, keep appending
        if more_to_write:
            for i in range(n_body, n_body + n_tail):
                card = override_header.cards[i]
                header.append(card, end=True)

        # if the original header has something left, delete them
        else:
            for i in range(n_body + n_tail - 1, n_body - 1, -1):
                del header[i]


def write_header_file(filename: str, header: fits.Header):
    with open(filename, "w") as f:
        f.write(header.tostring(sep="\n"))


###############################################################################
################         FITS_LDAC related functions         ##################
###############################################################################


def fitsrec_to_header(rec: FITS_rec) -> fits.Header:
    """Convert FITS_rec to astropy fits.Header"""

    content = rec[0][0]
    if isinstance(content, str):
        return fits.Header.fromstring(content)

    cards = (fits.Card.fromstring("COMMENT " + " " * 72 if c.strip() == "COMMENT" else c) for c in content if c.strip())
    return fits.Header(cards)


def header_to_fitsrec(header: fits.Header) -> FITS_rec:
    """
    Convert astropy fits.Header to FITS_rec. This is the data of the second HDU of the FITS_LDAC file.

    Mind the format is S80. To see it, do
    ```
    with fits.open(cat, character_as_bytes=True) as hdul:
        fits_rec = hdul[1].data
    fits_rec[0][0]
    ```
    fits.getdata() will change it to <U80.
    """

    text = header.tostring(sep="\n", endcard=True, padding=True)
    lines = text.splitlines()
    # cards_80 = [(ln + " " * 80)[:80] for ln in lines]
    # cards_s80 = np.asarray(cards_80, dtype="S80")
    cards_80 = [(ln + " " * 80)[:80].encode("ascii", "replace") for ln in lines]
    new_cards = np.asarray(cards_80, dtype="S80")  # shape (N,)
    vec = np.asarray(cards_80, dtype="S80")
    dtype = np.dtype([("Field Header Card", "S80", (len(vec),))])
    ra = np.recarray(shape=(1,), dtype=dtype)  # one-row record array
    ra["Field Header Card"][0] = vec  # fill the single cell

    fits_rec = ra.view(FITS_rec)
    return fits_rec  # access it by fits_rec[0][0]
